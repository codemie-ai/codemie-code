/**
 * Message Filtering Utilities
 *
 * Centralized filtering patterns for Claude session messages
 *
 * Categories:
 * 1. Conversation splitters - Commands that split sessions into multiple conversations
 * 2. System messages - Messages generated by the system that aren't user prompts
 * 3. Tool results - Already handled separately in transformer
 */

import type { ClaudeMessage, ContentItem } from './claude.conversations-types.js';

/**
 * Extract command from XML-wrapped format
 * Common pattern: <command-name>/memory-refresh</command-name>
 *
 * @param content - Message content (string or text)
 * @returns Command string (e.g., '/memory-refresh') or null if not found
 */
export function extractCommand(content: string): string | null {
  const commandMatch = content.match(/<command-name>(\/[^<]+)<\/command-name>/);
  return commandMatch ? commandMatch[1] : null;
}

/**
 * Conversation splitter commands that divide a session into multiple conversations
 * These commands are NOT synced as messages, but trigger conversation boundaries
 *
 * Note: Only /clear splits conversations. /compact and /compress are filtered as system commands
 * but do NOT create new conversation boundaries.
 */
const CONVERSATION_SPLITTERS = [
  '/clear'
];

/**
 * System message patterns that should be filtered out
 * These are NOT actual user prompts and should not be synced
 */
const SYSTEM_MESSAGE_PATTERNS = [
  // Caveat warnings about local command output
  'Caveat: The messages below were generated by the user while running local commands',
  // Slash command errors
  'Unknown slash command:',
  // Local command output wrappers
  '<local-command-stdout>',
  // User interruptions (cancelled requests)
  // Note: No closing bracket to match all variants like "for tool use", "for command", etc.
  '[Request interrupted by user',
  // Add more patterns as needed
];

/**
 * System commands that should be filtered out (not synced) but don't split conversations
 * These are different from CONVERSATION_SPLITTERS which create new conversation boundaries
 */
const SYSTEM_COMMANDS = [
  '/compact',
  '/compress'
];

/**
 * Helper: Check if message contains any command from the given list
 * @param msg - Claude message to check
 * @param commands - Array of commands to check for (e.g., ['/clear', '/compact'])
 * @returns true if message contains any of the commands
 */
function hasCommand(msg: ClaudeMessage, commands: string[]): boolean {
  if (msg.type !== 'user') return false;

  const content = msg.message?.content;

  // Check string content for XML format
  if (typeof content === 'string') {
    return commands.some(cmd =>
      content.includes(`<command-name>${cmd}</command-name>`)
    );
  }

  // Check array content for XML format in text items
  if (Array.isArray(content)) {
    for (const item of content) {
      if (item.type === 'text' && item.text) {
        if (commands.some(cmd =>
          item.text?.includes(`<command-name>${cmd}</command-name>`)
        )) {
          return true;
        }
      }
    }
  }

  return false;
}

/**
 * Check if message contains a conversation splitter command
 * These commands split the session but are not synced as messages
 *
 * @param msg - Claude message to check
 * @returns true if message is a conversation splitter command
 */
export function isConversationSplitter(msg: ClaudeMessage): boolean {
  return hasCommand(msg, CONVERSATION_SPLITTERS);
}

/**
 * Check if message is a system command (like /compact, /compress)
 * These are filtered out but don't split conversations
 *
 * @param msg - Claude message to check
 * @returns true if message is a system command
 */
function isSystemCommand(msg: ClaudeMessage): boolean {
  return hasCommand(msg, SYSTEM_COMMANDS);
}

/**
 * Check if message is a system message that should be filtered out
 * System messages are NOT user prompts and should not be synced
 *
 * @param msg - Claude message to check
 * @returns true if message is a system message
 */
export function isSystemMessage(msg: ClaudeMessage): boolean {
  if (msg.type !== 'user') return false;

  // Check if it's a system command (/compact, /compress)
  if (isSystemCommand(msg)) {
    return true;
  }

  const text = extractTextContent(msg);
  if (!text) return false;

  // Check against all system message patterns
  return SYSTEM_MESSAGE_PATTERNS.some(pattern =>
    text.startsWith(pattern)
  );
}

/**
 * Check if message is a tool result (only tool results, no text)
 * Tool results are NOT user prompts - they are incorporated into thoughts
 *
 * IMPORTANT: Only filters messages with ONLY tool_result content.
 * Messages with both text and tool_result should be processed normally
 * to extract the text content.
 *
 * @param msg - Claude message to check
 * @returns true if message contains ONLY tool results (no text content)
 */
export function isToolResult(msg: ClaudeMessage): boolean {
  if (msg.type !== 'user') return false;
  const content = msg.message?.content;
  if (!Array.isArray(content)) return false;

  // Check if message has tool_result content
  const hasToolResult = content.some((item: ContentItem) => item.type === 'tool_result');
  if (!hasToolResult) return false;

  // Check if message also has text content
  const hasText = content.some((item: ContentItem) =>
    item.type === 'text' && item.text?.trim()
  );

  // Only filter if message has tool_result AND no text content
  return hasToolResult && !hasText;
}

/**
 * Check if message should be filtered out (not synced as a user message)
 * This includes:
 * - Conversation splitters (/clear, /compact, /compress)
 * - System messages (caveats, errors)
 * - Tool results (incorporated into thoughts)
 *
 * @param msg - Claude message to check
 * @returns true if message should be filtered out
 */
export function shouldFilterMessage(msg: ClaudeMessage): boolean {
  return isConversationSplitter(msg) ||
         isSystemMessage(msg) ||
         isToolResult(msg);
}

/**
 * Extract text content from message
 * Helper function used by filters
 */
function extractTextContent(msg: ClaudeMessage): string {
  const content = msg.message?.content;

  if (typeof content === 'string') {
    return content;
  }

  if (Array.isArray(content)) {
    const textParts = content
      .filter((item: ContentItem) => item.type === 'text')
      .map((item: ContentItem) => item.text || '');
    return textParts.join('\n\n');
  }

  return '';
}
